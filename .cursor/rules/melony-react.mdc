---
description: Patterns for integrating Melony agents into React applications using @melony/react.
globs: **/*.tsx, **/hooks/*.ts
alwaysApply: false
---

# Melony React Integration

Use `@melony/react` to connect your frontend to a Melony agent stream and handle initialization.

## Initialization

Use `useMelonyInit` to fetch the initial UI state (typically via a `GET` request to your chat API).

```tsx
import { useMelonyInit } from "@melony/react";

function App() {
  const { data, loading, error } = useMelonyInit("/api/chat");

  if (loading) return <Spinner />;
  if (error) return <ErrorView error={error} />;

  return <MelonyProvider initialEvents={data?.events}>
    <Chat />
  </MelonyProvider>;
}
```

## Consuming the Stream

Use the `useMelony` hook to access messages and send events.

```tsx
const { messages, events, send, streaming, error } = useMelony();

// messages are aggregated events (text-deltas combined into single messages)
// events are the raw event stream
```

## Sending Events

```tsx
const handleSend = (text: string) => {
  send({ type: "user-message", data: { content: text } });
};
```

## Rendering Events (SDUI)

Iterate through `events` or `messages` and render components.

```tsx
{events.map((event) => {
  switch (event.type) {
    case "text":
      return <Text key={event.meta.id} content={event.data.content} />;
    case "weather-card":
      return <WeatherCard key={event.meta.id} {...event.data} />;
    default:
      return null;
  }
})}
```

## Best Practices
- **Aggregated Messages**: Use `messages` for chat bubbles (it merges `text-delta` events automatically).
- **Key by ID**: Always use `event.meta.id` (or `message.id`) as the React `key`.
- **Initialization**: Always provide `initialEvents` to `MelonyProvider` if you use `useMelonyInit`.
- **Optimistic UI**: The `send` method handles local state updates immediately.
