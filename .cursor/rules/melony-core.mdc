---
description: Standards and patterns for building Melony AI agents using the fluent builder API.
globs: **/agents/*.ts, **/plugins/*.ts, **/api/chat/*.ts
alwaysApply: false
---

# Melony Core Patterns

Melony is an event-based framework for AI agents. Use the `melony()` builder to define agents.

## Basic Agent Structure

```typescript
import { melony } from "melony";

export const agent = melony<State, Events>()
  .use(plugin)             // Load plugins
  .on("event", handler)    // Handle events
  .build();                // Finalize the agent
```

## Core Concepts

- **Events**: Objects with `{ type, data }`.
- **Handlers**: Functions `async function* (event, context)`. They are registered with `.on("type", handler)`.
- **Reactivity**: Yielding an event from a handler will cause the runtime to recursively process it through other handlers.
- **Plugins**: Functions that receive the `MelonyBuilder` and register handlers.

## Streaming in Next.js

```typescript
// app/api/chat/route.ts
export async function POST(req: Request) {
  const { event } = await req.json();
  return agent.streamResponse(event); // Returns a streaming Response
}
```

## Best Practices
- Keep agents modular by using **Plugins** (`MelonyPlugin`).
- Use **Server-Driven UI (SDUI)** by yielding custom event types that the frontend renders.
- To trigger another workflow, simply yield a new event: `yield { type: "other-event", data: { ... } }`.
