---
description: Conventions for writing Melony Event Handlers (async generators).
globs: **/handlers/*.ts
alwaysApply: false
---

# Melony Handler Patterns

Handlers are the building blocks of Melony agents. They respond to events and can yield new events.

## Defining a Handler

```typescript
import { EventHandler } from "melony";

export const myHandler: EventHandler<State, Events> = async function* (
  event,
  { state, runtime }
) {
  // 1. Initial feedback (SDUI or status)
  yield { type: "status", data: { message: "Calculating..." } };

  // 2. Perform logic
  const result = await someApi(event.data);

  // 3. Yield data or UI events
  yield { type: "my-result", data: result };
};
```

## Tool Handlers (action:*)

When using `@melony/plugin-ai-sdk`, tool calls automatically trigger events prefixed with `action:`.

```typescript
// For a tool named "getWeather"
export const getWeatherHandler: EventHandler = async function* (event) {
  // event.data contains the tool inputs (already validated via Zod)
  const { city } = event.data;
  
  const weather = await fetchWeather(city);
  
  // Yielding this will be sent back to the LLM as tool result
  // and can also be used to render UI
  yield { type: "weather-card", data: weather };
};
```

## Yielding Text (Streaming)

Use `text-delta` events for real-time text feedback.

```typescript
for await (const chunk of stream) {
  yield { type: "text-delta", data: { delta: chunk } };
}
```

## Key Principles

- **Yield Early and Often**: Provide immediate feedback (e.g., `status`, `text-delta`).
- **Narrowed Events**: When using `.on("type", handler)`, the `event` parameter is automatically narrowed to that type.
- **Recursion**: Yielding an event triggers the runtime to process it. Avoid infinite loops!
- **State**: Use the `context.state` to persist information across events in a single run.
- **SDUI**: Yield custom event types that match your frontend components.
